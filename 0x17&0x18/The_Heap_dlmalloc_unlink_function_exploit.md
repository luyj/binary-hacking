# 0x17 The Heap: Once upon a free() & 0x18 The Heap dlmalloc unlink() exploit
> 堆利用 unlink & GOT 覆盖
- **源代码**
  ```c
  #include <stdlib.h>
  #include <unistd.h>
  #include <string.h>
  #include <sys/types.h>
  #include <stdio.h>

  void winner()
  {
    printf("that wasn't too bad now, was it? @ %d\n", time(NULL));
  }

  int main(int argc, char **argv)
  {
    char *a, *b, *c;

    a = malloc(32);
    b = malloc(32);
    c = malloc(32);

    strcpy(a, argv[1]);
    strcpy(b, argv[2]);
    strcpy(c, argv[3]);

    free(c);
    free(b);
    free(a);

    printf("dynamite failed?\n");
  }
  ```
  实现的效果为需要执行 winner()，代码中存在危险函数调用时为进行长度限制。
- GDB 调试
  - 首先，对执行过程中对 `malloc()`、`free()`、`strcpy()`、`printf()` 函数调用进行断点调试，查看过程中堆区变化。（gdb下可用bins、heap 查看 chunk 及 空闲 chunk 链表，但是此二进制程序无法查看）
    - malloc 分配堆区变化
      ![](img/malloc_堆区变化.PNG)
    - strcpy 执行之后
      ![](img/strcpy_堆区变化.PNG)
      若输入超长字符串，则可将其它 `chunk()` 的 `chunk head()` 进行覆盖。但是如果除了需要覆盖之外，还需要考虑如何能够执行。这里，还是希望能通过对堆中数据的覆盖，可以获取函数的控制流，如，覆盖 GOT 的 `printf()` 地址，使得调用 printf 时实际调用的是 `winner()`
    - free 释放堆区变化
      - `free(c);`
      ![](img/free_堆区变化_1.PNG)
      - `free(b);`
      ![](img/free_堆区变化_2.PNG)
      - `free(a);`
      ![](img/free_堆区变化_3.PNG)
      由此，可以看到，在释放大小为32byte的堆时，实际上生成的空闲链表，对应 [malloc.c](../malloc.c)代码如下
      ![](img/free_fastbin.PNG)
      **当 chunk 块大小 < 80 byte 时，会将空闲块回收到 faskbin 单链表中，再分配时使用 LIFO（后进先出）**
      ![](img/free_fastbin.jpg)
      这里只有一个指针变化，无法完成指向指定地址并修改地址存储数据，固无法达到覆盖 GOT 的 `printf()` 地址，使得调用 printf 时实际调用的是 `winner()`效果
  - 通过阅读 [malloc.c](../malloc.c) 并直接通过 gdb 修改堆区数据的方式，尝试覆盖 printf GOT 表中对应地址的存储数据为 winner 函数地址
    - chunk 合并时会执行 unlink 操作，阅读代码，发现会合并前后两个 free chunk~~（后续补充修正，何时会使用unlink）~~
      执行 unlink 操作的情况包括前向合并和后向合并
       ![](img/unlink触发的两种情况.PNG)
       
       贴上作者生动图解:beer:
       ![](img/free_unlink.PNG)
       这里的操作是将待合并的 chunk 的前一个 chunk 的 fd 指针赋值给待前一个 chunk 的 bk 指针指向的 chunk 的 fd 指针，待合并的 chunk 的前一个 chunk 的 bk 指针赋值给待前一个 chunk 的 fd 指针指向的 chunk 的 bk 指针。因此，这里**有可指定地址并修改的操作（具备对指定地址写操作的条件）**。
        > For example, if the fd is the location of a GOT entry, then bk will be written into [fd]. So if bk is a pointer to a function you control, then you're golden.
    - 若将 `FD->bk` 覆盖为 printf GOT 地址，将 `BK` 覆盖为 winner 地址，即可完成操作，但是后续还有 `BK->fd = FD`，若 BK 指向的是 winner 地址，代码段只可读不可写，尝试修改会造成 segment fault，因此，不可直接进行修改。作者这里的解决办法为，使用 heap。:beers:
    ![](img/unlink利用_1.PNG)
    - 直接修改堆中数据
      ![](img/gdb_unlink利用_1.PNG)
      根据[malloc.c](../malloc.c)，程序会根据 pre_size 计算前一相邻空闲 chunk 的指针，因此改变 pre_size。
      ![](img/gdb_unlink利用_2.PNG)
      构造前一个相邻空闲块的 `fd` 指针和 `bk` 指针
      - puts@Global 地址
        ![](img/printf_global.PNG)
      - 覆盖 `P->fd` 为 `0x804b11c`
        ![](img/gdb_unlink利用_3.PNG)
      - 覆盖 `P->bk` 为 `0x804c010`
    - 执行 `free` 操作，可以看到，虽然 `puts@GLOBAL` 已被覆盖为指定值，但是程序 `segment fault` 异常
      ![](img/gdb_unlink利用_5.PNG)
      查看 [malloc.c](../malloc.c)
      ![](img/gdb_unlink利用_4.PNG)
      可以看到，在进行 4125 行 unlink 后，会判断 nextchunk 是否为 top chunk，如果不是，会判断 nextchunk 是否处于空闲状态，若为空闲状态，则会进一步执行 unlink 操作。因此，此处需要构造一个非空闲块，阻止进入 4134 行 unlink
      ![](img/gdb_unlink利用_6.PNG)
~~....未完待续:busstop:~~
    - 接下来应该用 strcpy 溢出来设置上述地址的值，但是这些值有很多 0x00，使用 strcpy 会被阶段，接下来，进入 0x18 :busstop:
- **漏洞利用**
  - 作者实际选择的是后向合并的 unlink 操作，并利用整型溢出来解决地址中带有 0x00 而用 strcpy 会被截断的问题
  
    根据 [malloc.c](../malloc.c) 对于 nextchunk 地址的计算方法
    ![](img/nextchunk计算.PNG)
    使用 strcpy 设置当前 chunk 大小 > 80 byte 并且当前 chunk 的 preinused 为 0，避免进入前向合并而需要构造更多合法 chunk
    ![](img/当前需要释放的chunk.PNG)
    而后构造需要从 空闲chunk 链表中脱离并与当前 free chunk 合并的 chunk
    ![](img/带合并nextchunk.PNG)
    **设置 `pre_size` 和 `size` 为 `0xfffffffc` 的原因**
    ```txt
    0xfffffffc        0xfffffffc          fd             bk
     |                 |              |              |
    size of next chunk  size of chunk  fwd pointer     backw pointer
    ```
    - **current chunk size `0xfffffffc`：**
      - 当前 chunk 的上一个 chunk 为空闲状态
      - next_chunk 地址为 `current_chunk_address + 0xfffffffc = current_chunk_address - 4`
    - **next chunk size `0xfffffffc`：**
      - 表明当前 chunk 为空闲状态
      - the address where you have to change the next chunk's "size" fields is 4 bytes (1 word) before the current chunk's "size" field.（没看懂）
    ![](img/nextchunk地址_2.PNG)
  
    **构造 fd 和 bk**
    - 设置 `fd = put@GOT - 12`，`bk` 为堆上某一地址（`0x804c008`）（不能直接写成 winner 的地址，因为这里写入是双向的，这样会涉及代码区的写入）
      ![](img/带合并nextchunk_1.PNG)
    - 设计 shellcode
      ![](img/shellcode.PNG)
    - 执行程序
      ![](img/free_result_1.PNG)
      发现放置 shellcode 的地址并无 shellcode
      ![](img/free_result_2.PNG)
      解决方法是不要在 chunk 头写数据
      ![](img/free_result_3.PNG)
      ![](img/free_result_4.PNG)

## 参考链接
- [exploit-protostar](https://exploit.education/protostar/) 
- [liveoverflow_binary-hacking](https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w)
- [heap overflow ctf-wiki](https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heapoverflow-basic/)
- [Exploit Excercises Phoenix Heap 1-3 solutions](https://pastebin.com/jy1yRhBc)
<!-- set {int}0x804c048=0x804b11c
set {int}0x804c04c=0x804c010
set {int}0x804c044=0x11
set {int}0x804c050=0x10
set {int}0x804c054=100
set {int}0x804c0b8=0x10
set {int}0x804c0c8=0x11
set {int}0x804c0cc=0x804c080
set {int}0x804c0d0=0x804c090 -->

        
